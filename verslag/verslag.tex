\documentclass[11pt,a4paper]{article}
\usepackage{graphicx}
\usepackage{sidecap}
\usepackage{mathtools}
%Om grotere integralen te krijgen
\usepackage{relsize}

%Andere breedte en lengthe van een document
\setlength{\textwidth}{6in} 
\addtolength{\hoffset}{-0.5in}
\setlength{\topmargin}{-0.2in}
\setlength{\textheight}{9in}

%Packages voor de figuren:
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}
%Kan er voor zorgen dat een figuur op de exacte plaats staat:
\usepackage{float}

%Package voor algoritmen:
\usepackage{algpseudocode}
\usepackage{algorithm}
\begin{document}
\begin{titlepage}

\title{\Huge Toepassingen van meetkunde in de informatica}

\author{Robin Goots\\
		Ward Schodts\\
		}

\date{2013 - 2014}
\maketitle
\thispagestyle{empty}


\begin{center}
\Large Professor Dirk Roose
\vfill
\end{center}
\end{titlepage}
\section{De onderzoeksvraag}
Hoe kunnen we de snijpunten van N cirkels vinden? 
\begin{enumerate}
\item Wat zijn de verschillende algoritmen?
\item Wat is de rekencomplexiteit van deze algoritmen?
\item In welke omstandigheden presteert het ene algoritme beter als het andere?
\end{enumerate}
\section{Hoogniveau beschrijving van de algoritmen}
\subsection{Algoritme 1}
Het eerste algortime is een brute-force algoritme. In essentie neemt het \'e\'en van de N cirkels en gaat het dan deze cirkel vergelijken met elke andere cirkel. Om zo te controleren of de cirkels overlappen en dusdanig \'e\'en of twee punten gemeenschappelijk hebben.
\\
\\
De complexiteit van het algoritme kan theoretisch gevonden worden op de volgende manier: er zijn $N$ cirkels, de eerste wordt gecontroleerd met $N-1$ anderen, de volgende met $N-2$ anderen, enzovoort. Dit geeft dus het volgende aantal controles:
$$(N-1) + (N-2) + (N-3) + (N - 4) \cdots $$
Dit is de som van de eerste $N-1$ getallen:
$$ = \frac{N\cdot (N-1)}{2} $$
Dit komt dus overeen met een rekencomplexiteit $O(N^2)$
\begin{algorithm}
\caption{eenvoudig algoritme met rekencomplexiteit $O(N^2)$}
\begin{algorithmic}
\State Lijst L met alle cirkels
\State Lijst ouput (met alle berekende snijpunten tussen de cirkels) = $\emptyset$
\While {Niet leeg L}
	\State Cirkel = L.NeemEnVerwijder()
	\For {c in L}
	\State snijptn = Cirkel.BerekenSnijpunten(c)
	\State output.VoegToe(snijptn)
	\EndFor
\EndWhile

\Return output
\end{algorithmic}
\end{algorithm}
\\
De functie \verb|NeemEnVerwijder()| geeft het eerste element van de lijst terug en verwijdert het daarna.\\
De functie \verb|BerekenSnijpunten(Cirkel c)| neemt als argument een cirkel aan en berekent de snijpunten met deze cirkel op de een andere cirkel waar deze methode werd uitgevoerd.
\subsection{Algoritme 2}
Voor het volgende algoritme stellen we elke cirkel voor als een lijnstuk met als links eindpunt het meest linkse punt van de cirkel en als rechts eindpunt het meest rechtse eindpunt van de cirkel. Deze twee punten worden bij in het object cirkel opgelsagen. Alle deze $2\cdot N$ punten worden gesorteerd op laagste x-coördinaat, daarna op laagste y-coördinaat, en uiteindelijk op het feit of dat het een links uiterste rechts uiterste is van de cirkel.
\begin{algorithm}
\caption{doorlooplijnalgoritme met rekencomplexiteit $O(N^2)$}
\begin{algorithmic}
\State Lijst L: een gesorteerde lijst met $2N$ punten.
\State Lijst C: met alle cirkels op een bepaald moment van een eventpoint, ongesorteerd.


\For {elk punt p in L}
	\If {p is het linkse eindpunt van een lijnstuk c}
	
		\State snijptn = Cirkel.BerekenSnijpunten(c)
		\State output.VoegToe(snijptn)	
		\State VoegToe(C,c)
		
	\EndIf
	\If {p is het rechtse eindpunt van een lijnstuk c}
		\State Verwijder(C,c)
	\EndIf
\EndFor

\Return output
\end{algorithmic}
\end{algorithm}

\subsection{Algoritme 3}
\begin{algorithm}
\caption{complex doorlooplijnalgoritme met rekencomplexiteit $O((N+S)Log(N))$}
\begin{algorithmic}
\State Lijst L: met alle punten, gesorteerd op het laagste x-co\"ordinaat daarna op het laagste y-co\"ordinaat en daarna komen linkse punten van een segment voor rechtse punten.
\State Lijst S: met alle segmenten op een bepaald moment van een eventpoint, ongesorteerd.
\For {elk punt p in de gesorteerde lijst}
	\If {p is het linkse eindpunt van een cirkel c}
	
		\State snijptn = Cirkel.BerekenSnijpunten(c)
		\State output.VoegToe(snijptn)
	
	\State VoegToe(C,c)
	\EndIf
	\If {p is het rechtse eindpunt van een cirkel c}
	\State Verwijder(C,c)
	\EndIf
\EndFor

\Return output
\end{algorithmic}
\end{algorithm}

\section{Correctheid van de algoritmen verifi\"eren}

Om de correctheid van de algoritmen te verifi\"eren hebben we verschillende stappen ondernomen. Deze stappen moeten in chronologische volgorde worden uitgevoerd omdat we assumpties uit voorgaande stappen gebruiken om te huidige stap te verifi\"eren.

\subsection{Enkele manuele testen}

\subsubsection*{bepalen dat twee cirkels snijden}

Onze eerste zorg is er zeker van zijn dat onze methode die bepaalt dat twee cirkels snijden correct werkt. Met behulp van internet hebben we formules afgeleid om te bepalen dat twee cirkels snijden of niet. Daarna hebben we deze formules omgezet in Python code.

\subsubsection*{Bepalen van snijpunten van twee cirkels}

Nu we er zeker van zijn dat we kunnen bepalen dat twee cirkels al dan niet snijden moeten we berekenen waar deze snijden. Wederom hebben we met behulp van internet formules afgeleid om snijpunten van twee circels te berekenen. Deze keer hebben we ook tussenstappen bepaald om te berekenen dat er \'e\'en of twee snijpunten zijn. Deze formules en tussenstappen hebben we ook omgezet in Python code.

\subsubsection*{Algoritme 1}

Aangezien algoritme \'e\'en alle cirkels met alle andere cirkels vergelijkt gaan er zeker geen snijpunten tussen twee cirkels verloren gaan. Verder hebben we al bewezen dat het bepalen dat twee cirkels snijden en de berekening van eventuele snijpunten correct zijn. Uit deze twee stellingen kunnen we concluderen dat algoritme \'e\'en correct is.
Om eventuele bugs in de code uit te sluiten hebben we een klein aantal cirkels handmatig berekend. Dit resultaat hebben we vergeleken met het resultaat dat onze code ons geeft.

\subsubsection*{Algoritme 2}

Bepalen dat algoritme twee correct is, is niet zo makkelijk als algoritme \'e\'en. De code voor het bepalen dat cirkels snijden en het berekenen van snijpunten hergebruiken we. Op deze manier zijn we zeker dat hier al geen fout meer kan inzitten.
Aangezien algoritme \'e\'en correct is moeten we met algoritme twee dezelfde uitkomst krijgen als we dezelfde invoer geven. Dit maakt het verifi\"eren van de correctheid al een stuk eenvoudiger.

Als eerst hebben we de uitkomst van algoritme \'e\'en en twee naast elkaar geplakt in een rekenblad. Nadat we beide uitkomsten sets gesorteerd hebben, hebben we een paar steekproeven genomen om te controleren of deze dezelfde zijn. Dit bleek zo te zijn. In dit zelfde rekenblad hebben we ook de som genomen van de x-waarden en de y-waarden. Deze twee sommen blijken ook overeen te komen. Uit deze twee proeven kunnen we concluderen dat de resultaten voor beide algoritmen overeen komen.

Na deze numerieke test hebben we ook nog een visuele test uitgevoerd. De resultaten die de algoritmes terug geven zijn eenvoudig om te zetten naar een Scalable Vector Graphics bestand. In dit bestand hebben we eerst alle snijpunten die algoritme \'e\'en opleverd geschreven in een bepaalde kleur. Daarne alle snijpunten die algoritme twee opleverd in een andere kleur. Aangezien enkel het laatst geschreven punt zichtbaar is, kunnen we makkelijk visueel controleren dat algoritme twee alle snijpunten vind door te controleren dat het geplotte svg bestand maar \'e\'en kleur weergeeft.

De numerieke en visuele test hebben we meermaals uitgevoerd met verschillende parameters voor de random gegenereerde cirkels om er zeker van te zijn dat onze testen niet toevallig slagen.

\subsubsection*{Algoritme 3}

De correctheid van algoritme drie gaan we op dezelde manier bepalen als algoritme twee. De code voor het bepalen dat cirkels snijden en het berekenen van snijpunten hergebruiken we wederom.

Als we de uitkomsten van algoritme \'e\'en en drie in een rekenblad plakken valt ons voor grote aantallen cirkels onmiddelijk op dat algoritme \'e\'en en drie niet hetzelfde aantal snijpunten vinden. Hieruit vermoeden we al dat algoritme drie niet correct werkt.

Ook de visuele test bevestigd ons vermoeden uit de numerieke test. De visuele test brengt wel een interessant gegeven aan het licht. Alle snijpunten die niet gevonden worden blijken in gebieden bij elkaar te liggen. Dit geeft ons het vermoeden dat er een fout zit in onze methode die de boom doorloopt opzoek naar snijdingen met het opgegeven segment.

\end{document}