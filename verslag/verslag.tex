\documentclass[11pt,a4paper]{article}
\usepackage{graphicx}
\usepackage{sidecap}
\usepackage{mathtools}
%Om grotere integralen te krijgen
\usepackage{relsize}

%Andere breedte en lengthe van een document
\setlength{\textwidth}{6in} 
\addtolength{\hoffset}{-0.5in}
\setlength{\topmargin}{-0.2in}
\setlength{\textheight}{9in}

%Packages voor de figuren:
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}
%Kan er voor zorgen dat een figuur op de exacte plaats staat:
\usepackage{float}

%Package voor algoritmen:
\usepackage{algpseudocode}
\usepackage{algorithm}
\begin{document}
\begin{titlepage}

\title{\Huge Toepassingen van meetkunde in de informatica}

\author{Robin Goots\\
		Ward Schodts\\
		}

\date{2013 - 2014}
\maketitle
\thispagestyle{empty}


\begin{center}
\Large Professor Dirk Roose
\vfill
\end{center}
\end{titlepage}

\section{De onderzoeksvraag}
Hoe kunnen we de snijpunten van N cirkels vinden? 
\begin{enumerate}
\item Wat zijn de verschillende algoritmen?
\item Wat is de rekencomplexiteit van deze algoritmen?
\item In welke omstandigheden presteert het ene algoritme beter als het andere?
\end{enumerate}

\section{Hoogniveau beschrijving van de algoritmen}
\subsection{Algoritme 1}
Het eerste algortime is een brute-force algoritme. In essentie neemt het \'e\'en van de N cirkels en gaat het dan deze cirkel vergelijken met elke andere cirkel. Om zo te controleren of de cirkels overlappen en dusdanig \'e\'en of twee punten gemeenschappelijk hebben.
\\
\\
De complexiteit van het algoritme kan theoretisch gevonden worden op de volgende manier: er zijn $N$ cirkels, de eerste wordt gecontroleerd met $N-1$ anderen, de volgende met $N-2$ anderen, enzovoort. Dit geeft dus het volgende aantal controles:
$$(N-1) + (N-2) + (N-3) + (N - 4) \cdots $$
Dit is de som van de eerste $N-1$ getallen:
$$ = \frac{N\cdot (N-1)}{2} $$
Dit komt dus overeen met een rekencomplexiteit $O(N^2)$
\begin{algorithm}
\caption{eenvoudig algoritme met rekencomplexiteit $O(N^2)$}
\begin{algorithmic}
\State Lijst L met alle cirkels

\While {Niet leeg L}
	\State Cirkel = L.NeemEnVerwijder
	\For {c in L}
	\State snijptn = Cirkel.BerekenSnijpunten(c)
	\State output.VoegToe(snijptn)
	\EndFor
\EndWhile

\Return output
\end{algorithmic}
\end{algorithm}
\subsection{Algoritme 2}
Voor het volgende algoritme stellen we elke cirkel voor als een lijnstuk met als links eindpunt het meest linkse punt van de cirkel en als rechts eindpunt het meest rechtse eindpunt van de cirkel.
\begin{algorithm}
\caption{doorlooplijnalgoritme met rekencomplexiteit $O(N^2)$}
\begin{algorithmic}
\State Lijst L: met alle punten, gesorteerd op het laagste x-co\"ordinaat, daarna op het laagste y-co\"ordinaat en daarna komen linkse punten van een lijnstuk voor rechtse punten van een lijnstuk.
\State Lijst C: met alle cirkels op een bepaald moment van een eventpoint, ongesorteerd.


\For {elk punt p in L}
	\If {p is het linkse eindpunt van een lijnstuk c}
	
		\State snijptn = Cirkel.BerekenSnijpunten(c)
		\State output.VoegToe(snijptn)	
		\State VoegToe(C,c)
		
	\EndIf
	\If {p is het rechtse eindpunt van een lijnstuk c}
		\State Verwijder(C,c)
	\EndIf
\EndFor

\Return output
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{complex doorlooplijnalgoritme met rekencomplexiteit $O((N+S)Log(N))$}
\begin{algorithmic}
\State Lijst L: met alle punten, gesorteerd op het laagste x-co\"ordinaat daarna op het laagste y-co\"ordinaat en daarna komen linkse punten van een segment voor rechtse punten.
\State Lijst S: met alle segmenten op een bepaald moment van een eventpoint, ongesorteerd.
\For {elk punt p in de gesorteerde lijst}
	\If {p is het linkse eindpunt van een cirkel c}
	
		\State snijptn = Cirkel.BerekenSnijpunten(c)
		\State output.VoegToe(snijptn)
	
	\State VoegToe(C,c)
	\EndIf
	\If {p is het rechtse eindpunt van een cirkel c}
	\State Verwijder(C,c)
	\EndIf
\EndFor

\Return output
\end{algorithmic}
\end{algorithm}

\section{Correctheid van de algoritmen verifi\"eren}

Om de correctheid van de algoritmen te verifi\"eren hebben we verschillende stappen ondernomen. Deze stappen moeten in chronologische volgorde worden uitgevoerd omdat we assumpties uit voorgaande stappen gebruiken om te huidige stap te verifi\"eren.

\subsection{Enkele manuele testen}

\subsubsection*{bepalen dat cirkels snijden}
Onze eerste zorg was er zeker van zijn dat onze methode voor het bepalen dat cirkels snijden correct werkt. Met behulp van internet hebben we formules afgeleid om te bepalen of cirkels snijden. Na dat we deze formules afgeleid hebben, hebben we deze omgezet in Python code.

\subsubsection*{Bepalen van snijpunten van twee cirkels}

Na dat we er zeker van zijn dat onze cirkels snijden of niet moeten we bepalen waar deze snijden. Wederom hebben we met behulp van internet formules afgeleid om de snijpunten van circels te bepalen. Deze keer hebben we ook tussenstappen bepaald om te berekenen dat er \'e\'en of twee snijpunten zijn. Deze formules hebben we ook omgezet in Python code.


\subsubsection*{Algoritme \'e\'en}

Aangezien in algoritme \'e\'en alle cirkels met alle andere cirkels vergeleken worden gaan we zeker geen snijpunten missen. Verder hebben we ook al bewezen dat het bepalen dat cirkels snijden en de bepaling van eventuele snijpunten correct zijn. Uit deze twee stellingen kunnen we concluderen dat algoritme \'e\'en correct is.
Om eventuele bugs in de code uit te sluiten hebben we een klein aantal cirkels handmatig berekend. Dit resultaat hebben we vergeleken met het resultaat dat onze code ons geeft.

\subsubsection*{Algoritme twee}

Bepalen dat algoritme twee correct is, is niet zo makkelijk als algoritme \'e\'en. De code voor het bepalen van dat cirkels snijden en het berekenen van snijpunten hergebruiken we. Op deze manier zijn we zeker dat hier al geen fout meer kan inzitten.
Aangezien algoritme \'e\'en correct is moeten we met algoritme twee dezelfde uitkomst krijgen als we dezelfde invoer geven. Dit maakt het verifi\"eren van de correctheid al een stuk eenvoudiger.

Als eerst hebben we de uitkomst van algoritme \'e\'en en twee naast elkaar geplakt in een rekenblad. Nadat we beide uitkomsten sets gesorteerd hebben, hebben we een paar steekproeven genomen om te controleren of deze dezelfde zijn. Dit bleek zo te zijn. In dit zelfde rekenblad hebben we ook de som genomen van de x-waarden en de y-waarden. Deze twee sommen blijken ook overeen te komen. Uit deze twee proeven kunnen we concluderen dat de resultaten voor beide algoritmen overeen komen.

Na deze numerieke test hebben we ook nog een visuele test uitgevoerd. De resultaten die de algoritmes terug geven zijn eenvoudig om te zetten naar een Scalable Vector Graphics bestand. In dit bestand hebben we eerst alle snijpunten die algoritme \'e\'en opleverd geschreven in een bepaalde kleur. Daarne alle snijpunten die algoritme twee opleverd in een andere kleur. Aangezien enkel het laatst geschreven punt zichtbaar is, kunnen we makkelijk visueel controleren dat algoritme twee alle snijpunten vind door te controleren dat het geplotte svg bestand maar \'e\'en kleur weergeeft. 

\end{document}